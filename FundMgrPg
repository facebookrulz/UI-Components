<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<body>
<link rel="stylesheet" href="jquery-ui-1.11.4.custom/mfMgr.css">
<link rel="stylesheet" href="jquery-ui-1.11.4.custom/jquery-ui.css">
<script src="jquery-ui-1.11.4.custom/external/jquery/jquery.js"></script>
<script src="jquery-ui-1.11.4.custom/jquery-ui.js"></script>
<script src="d3.min.js"></script>
<script src="dataManipulator.js"></script>
<script src="jquery-ui-1.11.4.custom/external/jquery/jquery-labrat-tip.js"></script>
<script src="jquery-ui-1.11.4.custom/external/jquery/d3-legend.js"></script>


<script>
//global VARIABLES
	window.master_array = new Array();	  
	window.bm_array = new Array();	  
	window.bm_Data_ = [];
	//this will store the fund selected by the user
	window.current_MF_Data_ = [];
	window._BM_MF_FromDt_idx = -1;
	window._BM_MF_ToDt_idx = -1; 
	var colors = d3.scale.category20();
	//to be read from a static file
	window.MFRiskReturnHeight = 400;
	window.MFRiskReturnWidth = 500;
	window.MFVsBMHeight = 400;
	window.MFVsBMWidth = 700;
	window.dispCircleRadius = 8;
	window.dispBMName = '';	
	window.dispMFName = '';
	//given that both BM and MF will have the same Date range 
	//we can read the current BM values itself
	function findIndex(findDt){
		
		for(ctr = 0 ;ctr < bm_Data_.length; ctr++){
			if( (bm_Data_[ctr].Date).getTime() === findDt.getTime() )
				return ctr;
		}
		return -1;
	}

	
	// to be called initially
	function initGlobalSetBM(){
	
			//FOR NOW use 0 index .. but we need to have a map
			// for MF data and bm index
			window.bm_Data_ = retDefaultBMData();
			dispBMName = retDefaultBMName();
			
			window.bm_Data_.forEach(function(d) {
					d.Date = new Date(d.Date);
					d.closing = +d.closing;
				  });
			console.log(' JUST FINISHED !!');	  
		//first time user sees chart she should be able to see only 50% of the total time period	  
		//then these 2 values are continually upDated in slider function
			if(window._BM_MF_FromDt_idx == -1 && window._BM_MF_ToDt_idx == -1){
				_BM_MF_FromDt_idx = Math.round( bm_Data_.length*(0.5) );	
				_BM_MF_ToDt_idx = bm_Data_.length-1;	  
			}
				
	}	 
	
	function setBMDataBasedOnMF(_mf_name){
		dispBMName = retBMName(_mf_name);
		dispMFName = _mf_name;
		bm_Data_ = retBMData(_mf_name);
		current_MF_Data_ = retMFData (_mf_name);
		//init
		bm_Data_.forEach(function(d) {
					d.Date = new Date(d.Date);
					d.closing = +d.closing;
				  });
		current_MF_Data_.forEach(function(d) {
					d.Date = new Date(d.Date);
					d.closing = +d.closing;
				  });
				  
		console.log("IN setBMDataBasedOnMF value of MF "+_mf_name+" and length "+ current_MF_Data_.length);
	}
	
	function _reScaleBM_MF_axes(init_Data_) {
	
	if (current_MF_Data_.length == 0)	  
				  current_MF_Data_ = bm_Data_;
			//both slices will have window prefix since we intend to use them outside this function	  
			window.sliced_bm_Data_ = calcDailyCumuChanges( bm_Data_.slice(_BM_MF_FromDt_idx, _BM_MF_ToDt_idx) );
			
			if(init_Data_ != null) //meaning its being called by click on mf circle ; else init
				current_MF_Data_ = init_Data_;
				
			window.current_Data_ = calcDailyCumuChanges( current_MF_Data_.slice(_BM_MF_FromDt_idx, _BM_MF_ToDt_idx) );
			
			
			var minDate = new Date(); var maxDate = new Date(); var minClose = 0; var maxClose = 0;
			// figure out the min and max shite
			if( d3.max(sliced_bm_Data_, function(d) { return d.cumuChg; }) > d3.max(current_Data_, function(d) { return d.cumuChg; }) )
				maxClose = d3.max(sliced_bm_Data_, function(d) { return d.cumuChg; });
			else
				maxClose = d3.max(current_Data_, function(d) { return d.cumuChg; });
				
			if( d3.min(sliced_bm_Data_, function(d) { return d.cumuChg; }) < d3.min(current_Data_, function(d) { return d.cumuChg; }) )
				minClose = d3.min(sliced_bm_Data_, function(d) { return d.cumuChg; });
			else
				minClose = d3.min(current_Data_, function(d) { return d.cumuChg; });
				
			if( d3.max(sliced_bm_Data_, function(d) { return d.Date; }) > d3.max(current_Data_, function(d) { return d.Date; }) )
				maxDate = d3.max(sliced_bm_Data_, function(d) { return d.Date; });
			else
				maxDate = d3.max(current_Data_, function(d) { return d.Date; });
				
			if( d3.min(sliced_bm_Data_, function(d) { return d.Date; }) < d3.min(current_Data_, function(d) { return d.Date; }) )
				minDate = d3.min(sliced_bm_Data_, function(d) { return d.Date; });
			else
				minDate = d3.min(current_Data_, function(d) { return d.Date; });
			//
			
			var line = d3.svg.line()
						.x(function(d) { return xScaler(d.Date); })
						.y(function(d) { return yScaler(d.cumuChg); });

			var svg = d3.select(".chart2");
			
			//clear existing
			svg.selectAll("path")
			.remove();
			
			//rescale if necessary
			
			xScaler.domain([minDate, maxDate]);
			yScaler.domain([minClose, maxClose]);
			
			//Date picker - set min and max Dates for the calendar to show
			// also setup call back function for Date closing ..if that happens
			// then you need call this _reScaleBM_MF_axes after resetting start and end index
			if(bm_Data_ == current_MF_Data_){
			
				$(function() {
						$( "#FromDt" ).datepicker( 
							{ minDate: bm_Data_[0].Date, 
							  maxDate: bm_Data_[bm_Data_.length-1].Date ,
							  beforeShowDay: $.datepicker.noWeekends , 
							  onClose: function(selectedDate) {
							  //need to pass via Date class since the selectedDate comes in as string
							  //*** whenever comparing or working with DATES lets stick to conversion into Date object***
							  
							  if( null !== selectedDate){
									var locStore = _BM_MF_FromDt_idx;
									_BM_MF_FromDt_idx = findIndex( new Date(selectedDate) );
									console.log('CON1 '+locStore+' '+_BM_MF_FromDt_idx+' '+_BM_MF_ToDt_idx);
									//set the slider values to the ones selected by the Date
									if ( _BM_MF_FromDt_idx < _BM_MF_ToDt_idx) {
										$( "#slider-range" ).slider( "values" , [ _BM_MF_FromDt_idx , _BM_MF_ToDt_idx] )
										//now call the rescale function
										_reScaleBM_MF_axes(null);
									}
									else{
										alert("sorry from's always going to be lesser than TO!!");
										_BM_MF_FromDt_idx = locStore;
										$( "#FromDt" ).datepicker( "setDate",  bm_Data_[_BM_MF_FromDt_idx].Date );
									}
								}
							  }
							} 
						);
						
				});
				
				$(function() {
						$( "#ToDt" ).datepicker(
							{ minDate: bm_Data_[0].Date, 
							  maxDate: bm_Data_[bm_Data_.length-1].Date ,
							  beforeShowDay: $.datepicker.noWeekends ,
							  onClose: function(selectedDate) {
							  
							  if( null !== selectedDate){
									var locStore = _BM_MF_ToDt_idx;
									_BM_MF_ToDt_idx = findIndex( new Date(selectedDate) );
									console.log('CON2 '+locStore+' '+_BM_MF_FromDt_idx+' '+_BM_MF_ToDt_idx);
									//set the slider values to the ones selected by the Date
									//but also check if the end dt > start ...
									if ( _BM_MF_FromDt_idx < _BM_MF_ToDt_idx) {
										$( "#slider-range" ).slider( "values" , [ _BM_MF_FromDt_idx , _BM_MF_ToDt_idx] )
										//now call the rescale function
										_reScaleBM_MF_axes(null);
									}else{
										alert("sorry from's always going to be lesser than TO!!");
										_BM_MF_ToDt_idx = locStore;
										$( "#ToDt" ).datepicker( "setDate",  bm_Data_[_BM_MF_ToDt_idx].Date );
									}
								  }
								
							  }
							} 
						);
				});
			}
			
			svg.select(".y.axis").transition().duration(500).ease("sin-in-out")  // https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease
                    .call(yAxis); 
		    svg.select(".x.axis").transition().duration(500).ease("sin-in-out")  // https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease
                    .call(xAxis); 				
			
			//add benchmark
		window.benchMarkPath =	svg.append("path")
			  .datum(sliced_bm_Data_)
			  .attr("class", "line")
			  .attr("d", line)
			  .attr("data-legend", dispBMName)
			  .attr("stroke","SpringGreen")
			  .attr("transform", "translate("+marOffsetX+","+marOffsetY+")")
			  
			//if the user hath selected some MF  
			if(bm_Data_ != current_MF_Data_){
				window.MFPath = svg.append("path")
				  .datum(current_Data_)
				  .attr("class", "line")
				  .attr("d", line)
				  .attr("data-legend", dispMFName)
				  .attr("stroke","Turquoise")
				  .attr("transform", "translate("+marOffsetX+","+marOffsetY+")")
				  
			}	  
			
			svg.selectAll(".legend").remove();
			//now set to and from Date calendars and also slider positions
			
			if ( _BM_MF_FromDt_idx < _BM_MF_ToDt_idx) {
				$( "#FromDt" ).datepicker( "setDate",  bm_Data_[_BM_MF_FromDt_idx].Date );
				$( "#ToDt" ).datepicker( "setDate",  bm_Data_[_BM_MF_ToDt_idx].Date );	
				$( "#slider-range" ).slider( "values" , [ _BM_MF_FromDt_idx , _BM_MF_ToDt_idx] )	
			}
			else{
				//better error handling ..for now just alert
				alert("sorry from dt's always going to be earlier than To Date ..never went to school ..sucker ?");
			}	
						
			legend = svg.append("g")
				.attr("class","legend")
				.attr("transform","translate(80,30)")
				.style("font-size","15px")
				.attr("data-style-padding",10)
				.call(d3.legend);
			//console();	

    }
</script>


    <div id = "MENU" >
        <div class="new">
            <ul>
                <li><a href="javascript:void(0);">Main</a></li>
                <li><a href="javascript:void(0);">Sectoral</a></li>
                <li><a class="current" href="javascript:void(0);">Risk</a></li>
                <li><a href="javascript:void(0);">Perf Attribution</a></li>
            </ul>
        </div>
    </div>

    <div id="MFRiskReturn" >
        <svg class="chart1" ></svg>
        
        <script>

			var margin = {top: 20, right: 20, bottom: 20, left: 20},
				width = MFRiskReturnWidth - margin.left - margin.right,
				height = MFRiskReturnHeight - margin.top - margin.bottom;

			var xFun = d3.scale.linear().domain([-10,10])
				.range([0,width]);

			var yFun = d3.scale.linear().domain([10,-10])
				.range([0,height]);

			var xAxis = d3.svg.axis()
				.scale(xFun)
				.orient("bottom");


			var yAxis = d3.svg.axis()
				.scale(yFun)
				.orient("left");
				
			var tip = d3.tip()
				  .attr('class', 'd3-tip')
				  .offset([-10, 0])
				  .html(function(d) {
					return "<strong>Risk:</strong> " + d.name +"<br><strong>Risk:</strong> " + d.x1 +"<br><strong>Return:</strong> " + d.x2 + "</span>";
				  })	

			var chart = d3.select(".chart1")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom);
				//.append("g")
				//.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			chart.call(tip);	
				
			//d3.csv("http://localhost:8080/test.csv", type, function(error, data) {
			//below is the risk return metric we will be using for charts

			var data_MF = retDataMFRiskReturn();

			data_MF.forEach(function(d) {
					d.x1 = +d.x1;
					d.x2 = +d.x2;
					d.name = d.name;
				  });
			
			//below we need to push each mf's  time series
			//for now we will use random numbers
			//**********below is where you should be placing MF data / arrays via static in django ********//
				
			
			chart.append("g")
				  .attr("class", "x axis")
				  .attr("transform", "translate(0,"+height/2+")")
				  .call(xAxis)
				  .append("text")
				  .attr("transform", "translate("+(width-30)+",-10)")
				  .attr("y", 2)
				  .attr("dy", "1em")
				  .style("text-anchor", "begin")
				  .text("HIGH RETURN");

			chart.append("g")
				  .attr("class", "y axis")
				  .attr("transform", "translate("+width/2+",0)")
				  .call(yAxis)
				  .append("text")
				  .attr("transform", "rotate(-90)")
				  .attr("y", 2)
				  .attr("dy", "1em")
				  .style("text-anchor", "end")
				  .text("HIGH RISK");
				  
			
			chart.selectAll(".bar")
				  .data(data_MF)
				  .enter()
				  .append("svg:circle")
				  .attr("fill", function(d, i) { return colors(i); })
				  .attr("r", function(d){ var store = 0;
											if(d.x1 > d.x2)
												store = Math.abs(d.x1)*10;
											else
												store = Math.abs(d.x2)*10;
											return store 
											
										} )
				  .attr("cx", function(d){return  xFun(d.x1) } )
				  .attr("cy", function(d){return  yFun(d.x2)} )
				  .on('click', function(d,i){ 
					setBMDataBasedOnMF( d.name ) ;
					_reScaleBM_MF_axes( retMFData(d.name) ) ;
				  })
				  .on('mouseover', tip.show )
				  .on('mouseout', tip.hide );
				  //.append("svg:title")
				  //.text(function(d) { return d.x1; });;
				  
				  
			</script>
    </div>
	
	<div id = "MFvsBM">
	<svg class="chart2" id="OK"></svg>
	<script>	
		var margin = {top: 20, right: 30, bottom: 20, left: 30},
		width = MFVsBMWidth - margin.left - margin.right,
		height = MFVsBMHeight - margin.top - margin.bottom;
		//width = 700 , height = 500 ;

		var parseDate = d3.time.format("%d-%b-%y").parse;
		//hopefully store slider values
		window.marOffsetX = margin.right;
		window.marOffsetY = margin.top;
		
		var xScaler = d3.time.scale()
			.range([0, width]);

		var yScaler = d3.scale.linear()
			.range([height, 0]);

		var xAxis = d3.svg.axis()
			.scale(xScaler)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScaler)
			.orient("left");

		var tipLineChart = d3.tip()
				  .attr('class', 'd3-tip')
				  //.offset([0, 0])
				  //.html(function(d) {
					//return "<strong>Risk:</strong> " + d.x1 +"<br><strong>Return:</strong> " + d.x2 + "</span>";
				  //})		
			
		var svg = d3.select(".chart2")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + (margin.top) + ")");
			//.attr("transform", "translate(0," + margin.top + ")");
		
		svg.call( tipLineChart );
		//d3.tsv("data.tsv", function(error, data) {
		//**********below is where you should be placing Benchmark data / arrays via static in django ********//
		 
		  //to init we call with 0 ..will need to change it after template mess
		  initGlobalSetBM();
		  
		  //add hover line
		  
		  // Hover line. 
			var hoverLineGroup = svg.append("g")
								.attr("class", "hover-line");
			var hoverLine = hoverLineGroup
				.append("line")
					.attr("x1", 10).attr("x2", 10) 
					.attr("y1", 0).attr("y2", height); 
			// Hide hover line by default.
			hoverLine.style("opacity", 0.1);
			
			//hoverLineGroup.call( tipLineChart );
			
			circleBenchMark = svg.append("circle")
				.attr("opacity", 0.00001)
				.attr({	r: dispCircleRadius, fill: 'SpringGreen' });

			circleMF = svg.append("circle")
				.attr("opacity", 0.00001)
				.attr({	r: dispCircleRadius, fill: 'Turquoise' });	
		  
		    d3.select(".chart2").on("mouseover", function() { 
			  
			  console.log('mouseover bugs');
			  
			}).on("mousemove", function() {
			  var xCoOrd = d3.mouse(this)[0];
			  var yCoOrd = d3.mouse(this)[1];
			  console.log("x and y coordinate Function ENTRY: " + [xCoOrd , yCoOrd] );
			  hoverLine.attr("x1", xCoOrd - margin.left ).attr("x2", xCoOrd - margin.left ).style("opacity", 0.2);
			  
			  
			    var pathLength = benchMarkPath.node().getTotalLength();
				console.log("bm length " + pathLength );
				//since our hover line has an offset from the xAxis our search
				//needs to begin from there rather than plain xCoord
				var x = xCoOrd - margin.left;
				var beginning = x,
					end = pathLength,
					target;
				while (true) {
					target = Math.floor((beginning + end) / 2);
					posBM = benchMarkPath.node().getPointAtLength(target);
					if ((target === end || target === beginning) && posBM.x !== x) {
						break;
					}
					if (posBM.x > x) end = target;
					else if (posBM.x < x) beginning = target;
					else break; //position found
				}
				//the code below is for the 2nd path i.e. MF line
				console.log("BEFORE : x and y coordinate where vertical line intersects graph: " + [posBM.x, posBM.y] );
				//decorate the dialogue
				
				locDt = xScaler.invert(posBM.x);
				
				tipLineChart//.attr("transform","translate("+(width - posBM.x)+","+(height - posBM.y)+")")
				.html(function(d) {
					
					return "<strong>Date:</strong> " +locDt.getDate()+"-"+locDt.getMonth()+"-"+locDt.getFullYear() +"<br><strong>"+ dispBMName +" % Chg:</strong> " + retDailyChange( sliced_bm_Data_ , ( xScaler.invert(posBM.x)) ).toFixed(2) + "</span>";
				})		
				
				if(bm_Data_ != current_MF_Data_){
						pathLength = MFPath.node().getTotalLength();
						console.log("MF length " + pathLength );
						//since our hover line has an offset from the xAxis our search
						//needs to begin from there rather than plain xCoord
						x = xCoOrd - margin.left;
						beginning = x,
							end = pathLength,
							target;
						while (true) {
							target = Math.floor((beginning + end) / 2);
							posMF = MFPath.node().getPointAtLength(target);
							if ((target === end || target === beginning) && posMF.x !== x) {
								break;
							}
							if (posMF.x > x) end = target;
							else if (posMF.x < x) beginning = target;
							else break; //position found
						}
						console.log("x and y coordinate where vertical line intersects graph: " + [posBM.x, posBM.y,posMF.x, posMF.y] );
						circleMF.attr("opacity", 0.5)
							.attr("cx", posMF.x )
							.attr("cy", posMF.y)
						console.log("data where vertical line intersects graph: " + [ xScaler.invert(posBM.x), yScaler.invert(posBM.y) ,xScaler.invert(posMF.x), yScaler.invert(posMF.y)]);	
						
						locDt = xScaler.invert(posMF.x);
						//html for hover box
						tipLineChart.html(function(d) {
							
							return "<strong>Date:</strong> " +locDt.getDate()+"-"+locDt.getMonth()+"-"+locDt.getFullYear() +"<br><strong>"+ dispBMName + "% Chg:</strong> " + retDailyChange( sliced_bm_Data_ , ( xScaler.invert(posBM.x)) ).toFixed(2) + "</span><br><strong>"+dispMFName+ "% Change:</strong>" + retDailyChange( current_Data_ , ( xScaler.invert(posMF.x)) ).toFixed(2);
						})
				}
				// end code for 2nd path
				circleBenchMark.attr("opacity", 0.5)
					.attr("cx", posBM.x )
					.attr("cy", posBM.y)
					
				
				
				
				console.log("data where vertical line intersects graph: " + [xScaler.invert(posBM.x), yScaler.invert(posBM.y)]);

			  
			  tipLineChart.show();
			  console.log('mousemove x', ( d3.mouse(this)[0] ));
			  console.log('mousemove y', ( d3.mouse(this)[1] ));
			  
			})  .on("mouseout", function() {
				console.log('mouseout');
				hoverLine.style("opacity", 0.001);
				circleBenchMark.attr("opacity", 0.001);
				circleMF.attr("opacity", 0.001);
				
				tipLineChart.hide();
		  });
		  		  // Hover line. 
				  
		  
		  xScaler.domain(d3.extent(bm_Data_, function(d) { return d.Date; }));
		  yScaler.domain(d3.extent(bm_Data_, function(d) { return d.closing; }));
		  
		  svg.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate("+marOffsetX+"," + height + ")")
			  .call(xAxis);

		  svg.append("g")
			  .attr("class", "y axis")
			  .call(yAxis)
			  .append("text")
			  .attr("transform", "rotate(-90)")
			  .attr("y", 2)
			  .attr("dy", "1em")
			  .style("text-anchor", "end")
			  .text("% Daily Change (%)");
		//call the final rendering
		
		_reScaleBM_MF_axes(bm_Data_); 	
		
		
		</script>
		<script>
		
		$(function() {
			var begDate = new Date();
			var endDate = new Date();
			$( "#slider-range" ).slider({
			  range: true,
			  min: 0,
			  max: bm_Data_.length-1,
			  //values: [ 0 , bm_Data_.length-2 ],
			  //the below is the call back function when the slider's moved
			  slide: function( event, ui ) {
				begDate = bm_Data_[ui.values[ 0 ]].Date;
				endDate = bm_Data_[ui.values[ 1 ]-1].Date;
				
				_BM_MF_FromDt_idx = ui.values[ 0 ];
				_BM_MF_ToDt_idx = ui.values[ 1 ];
				//this will call the resize for every event ..right now jarry and maybe we should call it once
				// after the slider has been laid to rest ?
				
				//
				
			  },
			  stop: function( event, ui ) {
				//rather than call it every movement in the above call it once after user lets go of handle
				_reScaleBM_MF_axes(null);
			  }
			});
			
		//first time init of Dates and alider
		$( "#FromDt" ).datepicker( "setDate",  bm_Data_[_BM_MF_FromDt_idx].Date );
		$( "#ToDt" ).datepicker( "setDate",  bm_Data_[_BM_MF_ToDt_idx].Date );
		$( "#slider-range" ).slider( "values" , [ _BM_MF_FromDt_idx , _BM_MF_ToDt_idx] );	
			
		  });
	
		
		</script>
		
	
	
	</div>
<div id="slider-range-header">
	<div id ="slider-text">
		<p>From Date: <input type="text" readonly='true' class="fromDate" id="FromDt" style="padding : 3px">     To Date: <input type="text" readonly='true' id="ToDt" style="padding : 3px"></p>
	</div>	
	<div id="slider-range"></div>
	
</div>

	

</body>
