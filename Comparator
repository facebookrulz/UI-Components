{% load staticfiles %}
<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<body>
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/spin.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/jquery-ui.min.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/component.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/component-button.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/normalize.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/bearbull.css' %}">
<script src="{% static 'jquery-ui-1.11.4.custom/external/jquery/jquery.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/jquery-ui.min.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/jquery.ui.slider.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/d3.min.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/external/jquery/jquery-labrat-tip.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/external/jquery/d3-legend.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/dataManipulator.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/snap.svg-min.js' %}"></script>

<script>
//global VARIABLES
	
	window.master_array = new Array();	  
	window.bm_array = new Array();	  
	window.bm_Data_ = [];
	window.bins = [0.13,0.12,0.11,0.1,0.09,0.08,0.07,0.06,0.05,0.04,0.03,0.02,0.01,0,-0.01,-0.02,-0.03,-0.04,-0.05,-0.06,-0.07,-0.08,-0.09,-0.1,-0.11,-0.12,-0.13];
	//this will store the fund selected by the user
	window.current_MF_Data_ = [];
	window._BM_MF_FromDt_idx = -1;
	window._BM_MF_ToDt_idx = -1; 
	var colors = d3.scale.category20();
	//to be read from a static file
	window.MFVsBMHeight = (300*screen.width)/(1920);
	window.MFVsBMWidth = (400*screen.width)/(1920);
	window.dispCircleRadius = 8;
	window.dispBMName = '';	
	window.dispMFName = '';
	window.isDragging = false;
	window.bnch = 'CNX Nifty';
	window.cmpAsset = "";
	window.assetType = "index";
	//given that both BM and MF will have the same dt range 
	//we can read the current BM values itself
	function findIndex(findDt){
		
		for(ctr = 0 ;ctr < bm_Data_.length; ctr++){
			if( (bm_Data_[ctr].dt).getTime() >= findDt.getTime() )
				return ctr;
		}
		return -1;
	}

	function genMsg(){
		//for now lets use averages of IQR and returns ..else lotsa if loops
		var retBetterOrWorse = ''
		var riskBetterOrWorse = ''
		var retBetterOrWorse1 = ''
		var riskBetterOrWorse1 = ''
		//first section for HV ..better or worse avg returns fr a phase as copared to the benchmark
		if ( (HVBMRet/2) > (HVAssetRet/2) && ((HVBMRet/2) - (HVAssetRet/2)) > 0.1 ){
			retBetterOrWorse = " lower ";	
		} 
		else if ( (HVBMRet/2) > (HVAssetRet/2) && ((HVBMRet/2) - (HVAssetRet/2)) < 0.1 )
			retBetterOrWorse = " similar ";	
		else if ( (HVBMRet/2) < (HVAssetRet/2) && ((HVBMRet/2) - (HVAssetRet/2)) < -0.1 )
                        retBetterOrWorse = " similar ";
		else
			retBetterOrWorse = " higher ";
		
		if ( HVBMIQR/2 > HVAssetIQR/2)
			riskBetterOrWorse = " lower ";
		else if ( HVBMIQR/2 < HVAssetIQR/2)
                        riskBetterOrWorse = " higher ";

		var HdrPara = 'The '+assetType+' '+cmpAsset+' has '+riskBetterOrWorse+' volatility during periods of High Volatility as compared to the benchmark. ';
		var Dtl =  'Looking at the High Volatility phases (Risk and return graphs to the LEFT ) one does notice the '+assetType+' '+cmpAsset+' has returns that are '+retBetterOrWorse+' as compared to the benchmark for a '+riskBetterOrWorse+' risk. ';
		
		//now generate message for Low Volatility		
		if ( (LVBMRet/2) > (LVAssetRet/2) && ((LVBMRet/2) - (LVAssetRet/2)) > 0.1 ){
			retBetterOrWorse1 = " lower ";	
		} 
		else if ( (LVBMRet/2) > (LVAssetRet/2) && ((LVBMRet/2) - (LVAssetRet/2)) < 0.1 )
			retBetterOrWorse1 = " similar ";	
		else if ( (LVBMRet/2) < (LVAssetRet/2) && ((LVBMRet/2) - (LVAssetRet/2)) < -0.1 )
                        retBetterOrWorse1 = " similar ";
		else
			retBetterOrWorse1 = " higher ";
		
		if ( LVBMIQR/2 > LVAssetIQR/2)
			riskBetterOrWorse1 = " lower ";
		else if ( LVBMIQR/2 < LVAssetIQR/2)
                        riskBetterOrWorse1 = " higher "; 


		HdrPara = HdrPara + 'During periods of Low Volatility it has '+riskBetterOrWorse1+' volatility . ';
		Dtl = Dtl + 'During Low Volatility (Risk and return graphs below) ,  it has returns that are '+retBetterOrWorse1+' as compared to the benchmark for a '+riskBetterOrWorse1+' risk. ';
		var addendum = '';	

		if(riskBetterOrWorse == " higher " && riskBetterOrWorse1 == " higher "){
			if (retBetterOrWorse1 ==  " higher " && retBetterOrWorse ==  " higher "){
				Dtl = Dtl +  cmpAsset+' is a steady bet in BULLISH / LOW Volatility Phases and BEARISH phases.';
			}
			else if (retBetterOrWorse1 ==  " higher " && retBetterOrWorse ==  " lower ")
				Dtl = Dtl + cmpAsset+' is a better bet in BULLISH / LOW Volatility Phases but NOT during BEARISH phases.';
			else
				Dtl = Dtl + cmpAsset+' is better avoided since it has higher volatility but lower returns across phases!!';
		}	
		else if(riskBetterOrWorse == " lower " && riskBetterOrWorse1 == " lower "){
			if (retBetterOrWorse1 ==  " higher " && retBetterOrWorse ==  " higher "){
				Dtl = Dtl +  cmpAsset+' has high odds of beating the market in BULLISH / LOW Volatility Phases and BEARISH phases.';
			}
			else if (retBetterOrWorse1 ==  " higher " && retBetterOrWorse ==  " lower ")
				Dtl = Dtl + cmpAsset+' is a safe bet in BULLISH / LOW Volatility Phases but NOT during BEARISH phases.';
		}	

	
		document.getElementById("Header1").innerHTML = 'Performance - Volatility Vs Returns'; 	
		document.getElementById("Header1-Para").innerHTML = HdrPara +'. To know more hover over me ...'; 	
		document.getElementById("DetailedHeader1").innerHTML = Dtl;	
	}

	$(document).ready(function(){
		$("#loader-wrapper").hide();
		$("#info1").hide();
		$("#HDR").hide();
	});
	
	// to be called initially
	function initGlobalSetBM( passLL, passHist, passTS, passDist, passIQR){
			console.log('FUCKER '+screen.width);	
			//FOR NOW use 0 index .. but we need to have a map
			// for MF data and bm index
			window.HVBMRet = 0.0;
			window.HVAssetRet = 0.0;
			window.LVBMRet = 0.0;
			window.LVAssetRet = 0.0;
			
			window.HVBMIQR = 0.0;
			window.HVAssetIQR = 0.0;
			window.LVBMIQR = 0.0;
			window.LVAssetIQR = 0.0;

			window.bm_Data_ = retDefaultBMData();
			//below 2 are python/django data
			if( passLL === undefined && passHist === undefined && passTS === undefined && passDist === undefined){
				window.tsList = {{ ll_list|safe  }};
				window.histList = {{ hist|safe  }};
				window.timeSeries = {{ ll|safe  }};
				window.distSeries = {{ dist_ll|safe  }};
				window.IQRList = {{ IQR|safe  }};
			}	
			else{
				window.tsList = passLL;
                                window.histList = passHist;
                                window.timeSeries = passTS;
                                window.distSeries = passDist;
				window.IQRList = passIQR;
			}

		
			if(tsList[0]['idx_name'] != bnch)
				cmpAsset = tsList[0]['idx_name'];
			else
				cmpAsset = tsList[1]['idx_name'];

			console.log('BATMAN '+cmpAsset+tsList[0]['idx_name']+'-'+tsList[1]['idx_name']+'-'+histList.length+'-'+histList['CNX Smallcap-FLAT2\r']);	
			window.timeSeriesDict = {};
			window.timeSeriesZeroDict = {};
			window.histMaster = {};	
			initTS();
			initHIST();

			dispBMName = retDefaultBMName();
			var format = d3.time.format( "%d-%b-%y" );
			window.bm_Data_.forEach(function(d) {
					d.dt = new Date(d.dt);
					d.closing = +d.closing;
				  });
			console.log(' JUST FINISHED !!');	  
		//first time user sees chart she should be able to see only 50% of the total time period	  
		//then these 2 values are continually updtd in dragslider function
			if(window._BM_MF_FromDt_idx == -1 && window._BM_MF_ToDt_idx == -1){
				_BM_MF_FromDt_idx = Math.round( bm_Data_.length*(0.5) );	
				_BM_MF_ToDt_idx = bm_Data_.length-1;	  
			}
		//initialize the autocomplete list
		

	}	 

	function refreshWithLatest( neo_data ){
		
		initGlobalSetBM(neo_data['ll_list'],neo_data['hist'],neo_data['ll'],neo_data['dist_ll'],neo_data['IQR']);

		_reScaleBM_MF_axes( ".chart2", "FLAT1",  1);
		_reScaleBM_MF_axes( ".chart22", "FLAT2", 0);
		_reScaleBM_MF_axes( ".chart23" , "BULL2", 1); 
		_reScaleBM_MF_axes(".chart24", "BULL3", 0);

		genHist(".histFlat1", "FLAT1");
		genHist(".histFlat2", "FLAT2");
		genHist(".histFlat3", "BULL2");
		genHist(".histFlat4", "BULL3");
		
		genMsg();
	
	}

	function retHistBinData(asset, phase){
		locList =  Object.keys(histMaster);
		
		for(histCtr = 0; histCtr< locList.length ; histCtr++){
			if ( locList[histCtr].indexOf( asset+'-'+phase ) > -1){
				return histMaster[locList[histCtr]]; 
			}
		}

		return -1;
	}
	
	function adder(a ){	
		var store = 0;
		for(Ctr = 0; Ctr< a.length ; Ctr++){
			store = store + a[Ctr]['value']
		}
	return store;	
	}
	
	
	function initHIST(){
	locList =  Object.keys(histList);
	var _chg_ = [];
                
		for(histCtr = 0; histCtr< locList.length ; histCtr++){
                        valArr = histList[locList[histCtr]];
			
			for(valCtr =0; valCtr < valArr.length; valCtr++){
        			var singleObj = {};
				singleObj['name'] = bins[valCtr];
                        	singleObj['value'] = valArr[valCtr];
				_chg_.push(singleObj)	
			}
			
		   histMaster[locList[histCtr]]=_chg_;	
		   _chg_ = [];	
                }

	}

	function initTS(){
		var phase = timeSeries[ 0 ].Phase;
   		var idx = timeSeries[ 0 ].idx_name;
   		var _per_chg_ = [];
		var cumSum = 0.0;

   		for (tsCtr = 1; tsCtr < timeSeries.length; tsCtr++){
        		var singleObj = {};
			var storeDt = ( timeSeries[ tsCtr ].idx_dt );
			var storeChg = ( timeSeries[ tsCtr ].cumChg );
			cumSum = cumSum + storeChg;
        			if( (timeSeries[ tsCtr ].Phase != phase || timeSeries[ tsCtr ].idx_name != idx) && _per_chg_.length > 0 ){
                			timeSeriesDict[idx+'-'+phase] = _per_chg_;
					//console.log(_per_chg_);	
                			phase = timeSeries[ tsCtr ].Phase;
                			idx = timeSeries[ tsCtr ].idx_name;
                			_per_chg_ = [];
					cumSum = 0.0;	
       				 }	
        		singleObj['dt'] = storeDt;
        		singleObj['cumuChg'] = cumSum;
			singleObj['zero'] = 0.0;
        		_per_chg_.push(singleObj);
   		}
		//fr the lst pair combo simply insert because it will come out when the tsCtr index reaches length
		timeSeriesDict[idx+'-'+phase] = _per_chg_;
	console.log('in initTS '+Object.keys(timeSeriesDict));

	}



	function retRelevantData( phase, asset ){
	console.log('in retRelevantData '+ asset+'-'+phase);
		var key_list = Object.keys(timeSeriesDict);
		var key_ctr = 0;
		while (key_ctr < key_list.length){
			//ding this because there seems to be some extra harecters being returned by key list ..i think its comeing from the db
 			// need to find method to trim extra chars
			console.log(key_list[key_ctr]);
			if(key_list[key_ctr].indexOf(asset+'-'+phase) > -1) break;
			key_ctr++;
		}
	//console.log('in retRelevantData '+timeSeriesDict[key_list[key_ctr]]);
	return timeSeriesDict[key_list[key_ctr]]
	}

        
	
	function setBMDataBasedOnMF(_mf_name){
		dispBMName = retBMName(_mf_name);
		dispMFName = _mf_name;
		bm_Data_ = retBMData(_mf_name);
		
		window.current_MF_Data_ = retMFData (_mf_name);
		console.log();
		//init
		bm_Data_.forEach(function(d) {
					
					d.dt = new Date(d.dt);
					
					d.closing = +d.closing;
				  });
		current_MF_Data_.forEach(function(d) {
					d.dt = new Date(d.dt);
					
					d.closing = +d.closing;
				  });
				  
		console.log("IN setBMDataBasedOnMF value of MF "+_mf_name+" and length "+ current_MF_Data_.length);
	}
	
	function _reScaleBM_MF_axes( area, phase, showLegend ){
	if (current_MF_Data_.length == 0){	  
				  current_MF_Data_ = bm_Data_;
				  }
			//both slices will have window prefix since we intend to use them outside this function	
			//defensive coding
			//if(_BM_MF_FromDt_idx >= 0 && _BM_MF_ToDt_idx >= 0){	
				window.sliced_bm_Data_ = retRelevantData(phase, bnch);
			
				//if(init_Data_ != null) //meaning its being called by click on mf circle ; else init
				//	current_MF_Data_ = init_Data_;
				console.log('GRRRRR '+cmpAsset);	
				window.current_Data_ = retRelevantData(phase, cmpAsset);
			//}
			
			sliced_bm_Data_.forEach(function(d) {
					d.dt = new Date(d.dt);
					d.cumuChg = +d.cumuChg;
					d.zero = +d.zero;
				  });
			
			current_Data_.forEach(function(d) {
					d.dt = new Date(d.dt);
					d.cumuChg = +d.cumuChg;
					d.zero = +d.zero;
				  });
			
			var mindt = new Date(); var maxdt = new Date(); var minClose = 0; var maxClose = 0;
			// figure out the min and max shite
			if( d3.max(sliced_bm_Data_, function(d) { return d.cumuChg; }) > d3.max(current_Data_, function(d) { return d.cumuChg; }) )
				maxClose = d3.max(sliced_bm_Data_, function(d) { return d.cumuChg; });
			else
				maxClose = d3.max(current_Data_, function(d) { return d.cumuChg; });
				
			if( d3.min(sliced_bm_Data_, function(d) { return d.cumuChg; }) < d3.min(current_Data_, function(d) { return d.cumuChg; }) )
				minClose = d3.min(sliced_bm_Data_, function(d) { return d.cumuChg; });
			else
				minClose = d3.min(current_Data_, function(d) { return d.cumuChg; });
				
			if( d3.max(sliced_bm_Data_, function(d) { return d.dt; }) > d3.max(current_Data_, function(d) { return d.dt; }) )
				maxdt = d3.max(sliced_bm_Data_, function(d) { return new Date(d.dt); });
			else
				maxdt = d3.max(current_Data_, function(d) { return new Date(d.dt); });
				
			if( d3.min(sliced_bm_Data_, function(d) { return d.dt; }) < d3.min(current_Data_, function(d) { return d.dt; }) )
				mindt = d3.min(sliced_bm_Data_, function(d) { return new Date(d.dt); });
			else
				mindt = d3.min(current_Data_, function(d) { return new Date(d.dt); });
			//
			
			var xScaler = d3.time.scale()
			.range([0, width]);

			var yScaler = d3.scale.linear()
			.range([height, 0]);
			
			var xAxis = d3.svg.axis()
			.scale(xScaler)
			.orient("bottom")
			.tickFormat(d3.time.format("%b"));

			var yAxis = d3.svg.axis()
			.scale(yScaler)
			.orient("left")
			//.tickValues([-0.04,-0.08, -0.15, -0.25, -0.35, -0.45,-1,0.04, 0.08, 0.15, 0.25, 0.35, 0.45,1])
			.tickFormat(d3.format("%"));
			
			var line = d3.svg.line()
						.x(function(d) { return xScaler((d.dt)); })
						.y(function(d) { return yScaler(d.cumuChg); });

			var line1 = d3.svg.line()
						.x(function(d) { return xScaler((d.dt)); })
						.y(function(d) { return yScaler(d.zero); });

			var svg = d3.select(area);
			
			//clear existing
			svg.selectAll("path")
			.remove();
			
			//rescale if necessary
			
			xScaler.domain([mindt, maxdt]);
			yScaler.domain([minClose, maxClose]);
			
			
			svg.select(".y.axis").transition().duration(500).ease("sin-in-out")  // https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease
                    .call(yAxis); 
		    svg.select(".x.axis").transition().duration(500).ease("sin-in-out")  // https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease
                    .call(xAxis); 	
		
			
			//add benchmark
		if( showLegend == 1){
			window.benchMarkPath =	svg.append("path")
			  .datum(sliced_bm_Data_)
			  .attr("class", "line")
			  .attr("d", line)
			  .attr("data-legend", bnch)
			  .attr("stroke","#5DA5DA")
			  .attr("transform", "translate("+marOffsetX+","+marOffsetY+")")
		}
		else{
			window.benchMarkPath =	svg.append("path")
			  .datum(sliced_bm_Data_)
			  .attr("class", "line")
			  .attr("d", line)
			  .attr("data-legend", 'Returns - '+phase)
			  .attr("stroke","#5DA5DA")
			  .attr("transform", "translate("+marOffsetX+","+marOffsetY+")")
		}
		//zero line
		window.benchMarkPath =  svg.append("path")
                          .datum(sliced_bm_Data_)
                          .attr("class", "line")
                          .attr("d", line1)
                          .attr("stroke","red")
			  .style("stroke-dasharray", ("6, 3"))	
                          .attr("transform", "translate("+marOffsetX+","+marOffsetY+")")
	  
			//if the user hath selected some MF  
			if( showLegend == 1){
				window.MFPath = svg.append("path")
				  .datum(current_Data_)
				  .attr("class", "line")
				  .attr("d", line)
				  .attr("data-legend", cmpAsset)
				  .attr("stroke","#F15854")
				  .attr("transform", "translate("+marOffsetX+","+marOffsetY+")")
			} else {
				window.MFPath = svg.append("path")
				  .datum(current_Data_)
				  .attr("class", "line")
				  .attr("d", line)
				  .attr("stroke","#F15854")
				  .attr("transform", "translate("+marOffsetX+","+marOffsetY+")")
			
			}		  
			
			
			svg.selectAll(".legend").remove();
			//now set to and from dt calendars and also dragslider positions
			
			if ( _BM_MF_FromDt_idx < _BM_MF_ToDt_idx) {
				$( "#FromDt" ).datepicker( "setdt",  bm_Data_[_BM_MF_FromDt_idx].dt );
				$( "#ToDt" ).datepicker( "setdt",  bm_Data_[_BM_MF_ToDt_idx].dt );	
				$( "#dragslider-range" ).dragslider( "values" , [ _BM_MF_FromDt_idx , _BM_MF_ToDt_idx] )	
			}
			else{
				//better error handling ..for now just alert
				alert("sorry from dt's always going to be earlier than To dt ..never went to school ..sucker ?");
			}	

			//if( showLegend == 1){				
				legend = svg.append("g")
				.attr("class","legend")
				.attr("transform","translate(70,25)")
				.style("font-size","15px")
				.attr("data-style-padding",10)
				.call(d3.legend);
			//}
// the below code handles putting labels at the end of line charts
				BMperiodRet = sliced_bm_Data_[sliced_bm_Data_.length-1]['cumuChg'];
				AssetperiodRet = current_Data_[current_Data_.length-1]['cumuChg'];
				if (phase == 'FLAT1' || phase == 'FLAT2'){
					HVBMRet = HVBMRet + BMperiodRet;
					HVAssetRet = HVAssetRet + AssetperiodRet;
				}	
				else if (phase == 'BULL2' || phase == 'BULL3'){
                                        LVBMRet = LVBMRet + BMperiodRet;
                                        LVAssetRet = LVAssetRet + AssetperiodRet;
                                }


			/*	
				var t1=0;
				var t2=0;
				
				if (yScaler(slicedLastVal)>=height)
					t1 = (yScaler(slicedLastVal)-10)
				else	
					t1 = (yScaler(slicedLastVal)+10)
					
				if (yScaler(currLastVal)>=height)
					t2 = (yScaler(currLastVal)-10)
				else	
					t2 = (yScaler(currLastVal)+10)	
				
					
				svg.append("text")
					.attr("transform", "translate(" + (width+3) + "," + t1 + ")")
					.attr("dy", ".35em")
					.attr("font-size", "20px")
					.attr("text-anchor", "start")
					.style("fill", "#5DA5DA")
					.style("font-weight", "bold")
					.text(Math.floor(slicedLastVal * 100)+'%' );

				svg.append("text")
					.attr("transform", "translate(" + (width+3) + "," + t2 + ")")
					.attr("dy", ".35em")
					.attr("font-size", "20px")
					.attr("text-anchor", "start")
					.style("fill", "#F15854")
					.style("font-weight", "bold")
					.text(Math.floor(currLastVal * 100)+'%' );
			*/

    }
	

	function genHist( area, phase ){

		var margin = {top: 20, right: 30, bottom: 20, left: 30},
                width = MFVsBMWidth - margin.left - margin.right,
                height = MFVsBMHeight - margin.top - margin.bottom;

		var x = d3.scale.ordinal()
			.rangeRoundBands([width,0], 0.1);
		var y = d3.scale.linear()
			.range([height,0]);

		var xAxis = d3.svg.axis()
			.scale(x)
			.orient("bottom")
			.tickValues([-0.12,-0.06,-0.02,0, 0.02, 0.04, 0.08, 0.13])
			.tickFormat(d3.format("%"));


		var yAxis = d3.svg.axis()
			.scale(y)
			.orient("left");
		
		var bnchData = retHistBinData( bnch, phase);
		var assData = retHistBinData( cmpAsset , phase);
		var normbnch = adder(bnchData);
		var normass = adder(assData);
		console.log('ass '+normbnch+'-'+normass);
		console.log('asshole '+ IQRList[bnch+'-'+phase+'\r']);

		if (phase == 'FLAT1' || phase == 'FLAT2'){
                                        HVBMIQR = HVBMIQR + IQRList[bnch+'-'+phase+'\r'];
                                        HVAssetIQR = HVAssetIQR + IQRList[cmpAsset+'-'+phase+'\r'];
                }
                else if (phase == 'BULL2' || phase == 'BULL3'){
                                        LVBMIQR = LVBMIQR + IQRList[bnch+'-'+phase+'\r'];
                                        LVAssetIQR = LVAssetIQR + IQRList[cmpAsset+'-'+phase+'\r']; 
                }


		x.domain(bnchData.map(function(d) { return d.name; }));
		if( d3.max( bnchData , function(d) { return d.value; }) > d3.max(assData , function(d) { return d.value; }) )
			y.domain([0, d3.max(bnchData , function(d) { return d.value/normbnch; })]);
		else
			y.domain([0, d3.max(assData , function(d) { return d.value/normass; })]);

		var chart = d3.select(area)
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		chart.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate(0,"+height+")")
			  .call(xAxis);


		chart.selectAll(".bar")
			  .data(bnchData)
			.enter().append("rect")
			  .attr("class", "bar")
			  .attr("x", function(d) { return x(d.name); })
			  .attr("y", function(d) { return y(d.value/normbnch); })
			  .attr("height", function(d) { return height - y(d.value/normbnch); })
			  .attr("width", x.rangeBand())
			  .on('click', function(d,i){  alert( d.value/normbnch ) ; })
			  .on('dblclick', function(d,i){  alert( d.name ) ; });

		chart.selectAll(".bar1")
			  .data(assData)
			.enter().append("rect")
			  .attr("class", "bar1")
			  //.attr("x", function(d) { return x(d.name)+x.rangeBand(); })
			  .attr("x", function(d) { return x(d.name)+ 5; })
			  .attr("y", function(d) { return y(d.value/normass); })
			  .attr("height", function(d) { return height - y(d.value/normass); })
			  .attr("width", x.rangeBand())
			  .attr("data-legend", "Volatility - "+phase)
			  .on('click', function(d,i){  alert( d.value/normbnch ); })
			  .on('dblclick', function(d,i){  alert( d.name ); });

		chart.append("g")
			.attr("class","legend")
			.attr("transform","translate(0,25)")
			.style("font-size","15px")
			.attr("data-style-padding",10)
			.call(d3.legend);	

		//});

		function type(d) {
		  d.value = +d.value; // coerce to number
		  return d;
		}
	}
</script>

	<div id = "HDR1">
               <p id="HeaderButton">
		 <button class="btn btn-7 btn-7a ">Fund Of Funds</button>
               	 <button class="btn btn-7 btn-7a ">Fund House</button>
		 <button class="btn btn-7 btn-7a ">Fund Manager</button>
               	 <button class="btn btn-7 btn-7a ">Synthetic Portfolios</button>
	       </p>
	</div>


	
	<div id = "MFvsBM">

	<div id="loader-wrapper">
    		<div id="loader"></div>
	</div>

	<div id = "upperLCContainer">
	<div id = "MFvsBM">
	<svg class="chart2" id="OK"></svg>
	<script>
		initGlobalSetBM();	
		var margin = {top: 20, right: 30, bottom: 20, left: 30},
		width = MFVsBMWidth - margin.left - margin.right,
		height = MFVsBMHeight - margin.top - margin.bottom;
		//width = 700 , height = 500 ;

		var parsedt = d3.time.format("%d-%b-%y").parse;
		//hopefully store dragslider values
		window.marOffsetX = margin.right;
		window.marOffsetY = margin.top;
		
		var xScaler = d3.time.scale()
			.range([0, width]);

		var yScaler = d3.scale.linear()
			.range([height, 0]);

		var xAxis = d3.svg.axis()
			.scale(xScaler)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScaler)
			.orient("left");

		var tipLineChart = d3.tip()
				  .attr('class', 'd3-tip')
				  //.offset([0, 0])
				  //.html(function(d) {
					//return "<strong>Risk:</strong> " + d.x1 +"<br><strong>Return:</strong> " + d.x2 + "</span>";
				  //})		
			
		var svg = d3.select(".chart2")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + (margin.top) + ")");
			//.attr("transform", "translate(0," + margin.top + ")");
		
		svg.call( tipLineChart );
		//d3.tsv("data.tsv", function(error, data) {
		//**********below is where you should be placing Benchmark data / arrays via static in django ********//
		 
		  //to init we call with 0 ..will need to change it after template mess
		  
		  //add hover line
		  
		  // Hover line. 
			var hoverLineGroup = svg.append("g")
								.attr("class", "hover-line");
			var hoverLine = hoverLineGroup
				.append("line")
					.attr("x1", 10).attr("x2", 10) 
					.attr("y1", 0).attr("y2", height); 
			// Hide hover line by default.
			hoverLine.style("opacity", 0.1);
			
			//hoverLineGroup.call( tipLineChart );
			
			circleBenchMark = svg.append("circle")
				.attr("opacity", 0.00001)
				.attr({	r: dispCircleRadius, fill: 'SpringGreen' });

			circleMF = svg.append("circle")
				.attr("opacity", 0.00001)
				.attr({	r: dispCircleRadius, fill: 'Turquoise' });	
		  
		    d3.select(".chart2").on("mouseover", function() { 
			  
			  console.log('mouseover bugs');
			  
			}).on("mousemove", function() {
			  var xCoOrd = d3.mouse(this)[0];
			  var yCoOrd = d3.mouse(this)[1];
			  //console.log("x and y coordinate Function ENTRY: " + [xCoOrd , yCoOrd] );
			  hoverLine.attr("x1", xCoOrd - margin.left ).attr("x2", xCoOrd - margin.left ).style("opacity", 0.2);
			  
			  
			    var pathLength = benchMarkPath.node().getTotalLength();
				//console.log("bm length " + pathLength );
				//since our hover line has an offset from the xAxis our search
				//needs to begin from there rather than plain xCoord
				var x = xCoOrd - margin.left;
				var beginning = x,
					end = pathLength,
					target;
				while (true) {
					target = Math.floor((beginning + end) / 2);
					posBM = benchMarkPath.node().getPointAtLength(target);
					if ((target === end || target === beginning) && posBM.x !== x) {
						break;
					}
					if (posBM.x > x) end = target;
					else if (posBM.x < x) beginning = target;
					else break; //position found
				}
				//the code below is for the 2nd path i.e. MF line
				//console.log("BEFORE : x and y coordinate where vertical line intersects graph: " + [posBM.x, posBM.y] );
				//decorate the dialogue
				
				locDt = xScaler.invert(posBM.x);
				
				tipLineChart//.attr("transform","translate("+(width - posBM.x)+","+(height - posBM.y)+")")
				.html(function(d) {
					
					return "<strong>dt:</strong> " +locDt.getDate()+"-"+(parseInt(locDt.getMonth())+1)+"-"+locDt.getFullYear() +"<br><strong>"+ dispBMName +" % Chg:</strong> " + retDailyChange( sliced_bm_Data_ , ( xScaler.invert(posBM.x)) ).toFixed(2) + "</span>";
				})		
				
				if(bm_Data_ != current_MF_Data_){
						pathLength = MFPath.node().getTotalLength();
						//console.log("MF length " + pathLength );
						//since our hover line has an offset from the xAxis our search
						//needs to begin from there rather than plain xCoord
						x = xCoOrd - margin.left;
						beginning = x,
							end = pathLength,
							target;
						while (true) {
							target = Math.floor((beginning + end) / 2);
							posMF = MFPath.node().getPointAtLength(target);
							if ((target === end || target === beginning) && posMF.x !== x) {
								break;
							}
							if (posMF.x > x) end = target;
							else if (posMF.x < x) beginning = target;
							else break; //position found
						}
						//console.log("x and y coordinate where vertical line intersects graph: " + [posBM.x, posBM.y,posMF.x, posMF.y] );
						circleMF.attr("opacity", 0.5)
							.attr("cx", posMF.x )
							.attr("cy", posMF.y)
						//console.log("data where vertical line intersects graph: " + [ xScaler.invert(posBM.x), yScaler.invert(posBM.y) ,xScaler.invert(posMF.x), yScaler.invert(posMF.y)]);	
						
						locDt = xScaler.invert(posMF.x);
						//html for hover box
						tipLineChart.html(function(d) {
							
							return "<strong>dt:</strong> " +locDt.getDate()+"-"+(parseInt(locDt.getMonth())+1)+"-"+locDt.getFullYear() +"<br><strong>"+ dispBMName + "% Chg:</strong> " + retDailyChange( sliced_bm_Data_ , ( xScaler.invert(posBM.x)) ).toFixed(2) + "</span><br><strong>"+dispMFName+ "% Change:</strong>" + retDailyChange( current_Data_ , ( xScaler.invert(posMF.x)) ).toFixed(2);
						})
				}
				// end code for 2nd path
				circleBenchMark.attr("opacity", 0.5)
					.attr("cx", posBM.x )
					.attr("cy", posBM.y)
					
				
				
				
				//console.log("data where vertical line intersects graph: " + [xScaler.invert(posBM.x), yScaler.invert(posBM.y)]);

			  
			  tipLineChart.show();
			  //console.log('mousemove x', ( d3.mouse(this)[0] ));
			  //console.log('mousemove y', ( d3.mouse(this)[1] ));
			  
			})  .on("mouseout", function() {
				//console.log('mouseout');
				hoverLine.style("opacity", 0.001);
				circleBenchMark.attr("opacity", 0.001);
				circleMF.attr("opacity", 0.001);
				
				tipLineChart.hide();
		  });
		  		  // Hover line. 
				  
		  
		  xScaler.domain(d3.extent(bm_Data_, function(d) { return d.dt; }));
		  yScaler.domain(d3.extent(bm_Data_, function(d) { return d.closing; }));
		  
		  svg.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate("+marOffsetX+"," + height + ")")
			  .call(xAxis);

		  svg.append("g")
			  .attr("class", "y axis")
			  .call(yAxis)
			  .append("text")
			  .attr("transform", "rotate(-90)")
			  .attr("y", 2)
			  .attr("dy", "1em")
			  .style("text-anchor", "end")
			  .text("Cumulative Change (%)");
		//call the final rendering
		_reScaleBM_MF_axes( ".chart2", "FLAT1", 1); 	
		
		
	</script>
		
	
	</div>



	<div id = "MFvsBM">
	<svg class="chart22" id="OK"></svg>
	<script>	
		var margin = {top: 20, right: 30, bottom: 20, left: 30},
		width = MFVsBMWidth - margin.left - margin.right,
		height = MFVsBMHeight - margin.top - margin.bottom;
		//width = 700 , height = 500 ;

		var parsedt = d3.time.format("%d-%b-%y").parse;
		//hopefully store dragslider values
		window.marOffsetX = margin.right;
		window.marOffsetY = margin.top;
		
		var xScaler = d3.time.scale()
			.range([0, width]);

		var yScaler = d3.scale.linear()
			.range([height, 0]);

		var xAxis = d3.svg.axis()
			.scale(xScaler)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScaler)
			.orient("left");

		var tipLineChart = d3.tip()
				  .attr('class', 'd3-tip')
				  //.offset([0, 0])
				  //.html(function(d) {
					//return "<strong>Risk:</strong> " + d.x1 +"<br><strong>Return:</strong> " + d.x2 + "</span>";
				  //})		
			
		var svg = d3.select(".chart22")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + (margin.top) + ")");
			//.attr("transform", "translate(0," + margin.top + ")");
		
		svg.call( tipLineChart );
		//d3.tsv("data.tsv", function(error, data) {
		//**********below is where you should be placing Benchmark data / arrays via static in django ********//
		 
		  //to init we call with 0 ..will need to change it after template mess
		  
		  //add hover line
		  
		  // Hover line. 
			var hoverLineGroup = svg.append("g")
								.attr("class", "hover-line");
			var hoverLine = hoverLineGroup
				.append("line")
					.attr("x1", 10).attr("x2", 10) 
					.attr("y1", 0).attr("y2", height); 
			// Hide hover line by default.
			hoverLine.style("opacity", 0.1);
			
			//hoverLineGroup.call( tipLineChart );
			
			circleBenchMark = svg.append("circle")
				.attr("opacity", 0.00001)
				.attr({	r: dispCircleRadius, fill: 'SpringGreen' });

			circleMF = svg.append("circle")
				.attr("opacity", 0.00001)
				.attr({	r: dispCircleRadius, fill: 'Turquoise' });	
		  
		    d3.select(".chart2").on("mouseover", function() { 
			  
			  console.log('mouseover bugs');
			  
			}).on("mousemove", function() {
			  var xCoOrd = d3.mouse(this)[0];
			  var yCoOrd = d3.mouse(this)[1];
			  //console.log("x and y coordinate Function ENTRY: " + [xCoOrd , yCoOrd] );
			  hoverLine.attr("x1", xCoOrd - margin.left ).attr("x2", xCoOrd - margin.left ).style("opacity", 0.2);
			  
			  
			    var pathLength = benchMarkPath.node().getTotalLength();
				//console.log("bm length " + pathLength );
				//since our hover line has an offset from the xAxis our search
				//needs to begin from there rather than plain xCoord
				var x = xCoOrd - margin.left;
				var beginning = x,
					end = pathLength,
					target;
				while (true) {
					target = Math.floor((beginning + end) / 2);
					posBM = benchMarkPath.node().getPointAtLength(target);
					if ((target === end || target === beginning) && posBM.x !== x) {
						break;
					}
					if (posBM.x > x) end = target;
					else if (posBM.x < x) beginning = target;
					else break; //position found
				}
				//the code below is for the 2nd path i.e. MF line
				//console.log("BEFORE : x and y coordinate where vertical line intersects graph: " + [posBM.x, posBM.y] );
				//decorate the dialogue
				
				locDt = xScaler.invert(posBM.x);
				
				tipLineChart//.attr("transform","translate("+(width - posBM.x)+","+(height - posBM.y)+")")
				.html(function(d) {
					
					return "<strong>dt:</strong> " +locDt.getDate()+"-"+(parseInt(locDt.getMonth())+1)+"-"+locDt.getFullYear() +"<br><strong>"+ dispBMName +" % Chg:</strong> " + retDailyChange( sliced_bm_Data_ , ( xScaler.invert(posBM.x)) ).toFixed(2) + "</span>";
				})		
				
				if(bm_Data_ != current_MF_Data_){
						pathLength = MFPath.node().getTotalLength();
						//console.log("MF length " + pathLength );
						//since our hover line has an offset from the xAxis our search
						//needs to begin from there rather than plain xCoord
						x = xCoOrd - margin.left;
						beginning = x,
							end = pathLength,
							target;
						while (true) {
							target = Math.floor((beginning + end) / 2);
							posMF = MFPath.node().getPointAtLength(target);
							if ((target === end || target === beginning) && posMF.x !== x) {
								break;
							}
							if (posMF.x > x) end = target;
							else if (posMF.x < x) beginning = target;
							else break; //position found
						}
						//console.log("x and y coordinate where vertical line intersects graph: " + [posBM.x, posBM.y,posMF.x, posMF.y] );
						circleMF.attr("opacity", 0.5)
							.attr("cx", posMF.x )
							.attr("cy", posMF.y)
						//console.log("data where vertical line intersects graph: " + [ xScaler.invert(posBM.x), yScaler.invert(posBM.y) ,xScaler.invert(posMF.x), yScaler.invert(posMF.y)]);	
						
						locDt = xScaler.invert(posMF.x);
						//html for hover box
						tipLineChart.html(function(d) {
							
							return "<strong>dt:</strong> " +locDt.getDate()+"-"+(parseInt(locDt.getMonth())+1)+"-"+locDt.getFullYear() +"<br><strong>"+ dispBMName + "% Chg:</strong> " + retDailyChange( sliced_bm_Data_ , ( xScaler.invert(posBM.x)) ).toFixed(2) + "</span><br><strong>"+dispMFName+ "% Change:</strong>" + retDailyChange( current_Data_ , ( xScaler.invert(posMF.x)) ).toFixed(2);
						})
				}
				// end code for 2nd path
				circleBenchMark.attr("opacity", 0.5)
					.attr("cx", posBM.x )
					.attr("cy", posBM.y)
					
				
				
				
				//console.log("data where vertical line intersects graph: " + [xScaler.invert(posBM.x), yScaler.invert(posBM.y)]);

			  
			  tipLineChart.show();
			  //console.log('mousemove x', ( d3.mouse(this)[0] ));
			  //console.log('mousemove y', ( d3.mouse(this)[1] ));
			  
			})  .on("mouseout", function() {
				//console.log('mouseout');
				hoverLine.style("opacity", 0.001);
				circleBenchMark.attr("opacity", 0.001);
				circleMF.attr("opacity", 0.001);
				
				tipLineChart.hide();
		  });
		  		  // Hover line. 
				  
		  
		  xScaler.domain(d3.extent(bm_Data_, function(d) { return d.dt; }));
		  yScaler.domain(d3.extent(bm_Data_, function(d) { return d.closing; }));
		  
		  svg.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate("+marOffsetX+"," + height + ")")
			  .call(xAxis);

		  svg.append("g")
			  .attr("class", "y axis")
			  .call(yAxis)
			  .append("text")
			  .attr("transform", "rotate(-90)")
			  .attr("y", 2)
			  .attr("dy", "1em")
			  .style("text-anchor", "end")
			  .text("Cumulative Change (%)");
		//call the final rendering
		
		_reScaleBM_MF_axes( ".chart22", "FLAT2", 0); 	
		
		
	</script>
	</div>

	</div>

	<div id = "ListTextContainer">
	
	 <div id = "BMList">	
		<label for="search">Another Benchmark ? </label>
		<input id="search">
	</div>

	<div id = "MFvsBMText">
	<div id = "info1">
			<p id="DetailedHeader1"> PlaceHolder </p>
	</div>
	
	<section id="grid" class="grid clearfix">
		<a href="#" data-path-hover="m 180,34.57627 -180,0 L 0,0 180,0 z">
		
		  <!--<svg viewBox="0 0 0 320" preserveAspectRatio="none"><path d="M 180,300 0,300 0,0 180,0 z"/></svg>-->
		  <svg viewBox="0 0 0 320" preserveAspectRatio="none"><path d="M 180,300 0,300 0,0 180,0 z"/></svg>
			<figcaption>
				<h2 id="Header1">PlaceHolder</h2>
				<p id="Header1-Para">PlaceHolder</p>
                 	</figcaption>
		
		</a>	
	</section>
        </div>

	</div>

	<div id = "upperHistContainer">
	<div id = "MFHist">
	<svg class="histFlat1"></svg>
        <script>

		genHist(".histFlat1", "FLAT1");
		
	</script>	

	</div>

	<div id = "MFHist">
	
	<svg class="histFlat2"></svg>
        <script>
		genHist(".histFlat2", "FLAT2");

	</script>	
	</div>
	
	</div>



	<div id = "lowerLCContainer">

	<div id = "MFvsBM1">
	<svg class="chart23" id="OK"></svg>
	<script>	
		var margin = {top: 20, right: 30, bottom: 20, left: 30},
		width = MFVsBMWidth - margin.left - margin.right,
		height = MFVsBMHeight - margin.top - margin.bottom;
		//width = 700 , height = 500 ;

		var parsedt = d3.time.format("%d-%b-%y").parse;
		//hopefully store dragslider values
		window.marOffsetX = margin.right;
		window.marOffsetY = margin.top;
		
		var xScaler = d3.time.scale()
			.range([0, width]);

		var yScaler = d3.scale.linear()
			.range([height, 0]);

		var xAxis = d3.svg.axis()
			.scale(xScaler)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScaler)
			.orient("left");

		var tipLineChart = d3.tip()
				  .attr('class', 'd3-tip')
				  //.offset([0, 0])
				  //.html(function(d) {
					//return "<strong>Risk:</strong> " + d.x1 +"<br><strong>Return:</strong> " + d.x2 + "</span>";
				  //})		
			
		var svg = d3.select(".chart23")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + (margin.top) + ")");
			//.attr("transform", "translate(0," + margin.top + ")");
		
		svg.call( tipLineChart );
		//d3.tsv("data.tsv", function(error, data) {
		//**********below is where you should be placing Benchmark data / arrays via static in django ********//
		 
		  //to init we call with 0 ..will need to change it after template mess
		  
		  //add hover line
		  
		  // Hover line. 
			var hoverLineGroup = svg.append("g")
								.attr("class", "hover-line");
			var hoverLine = hoverLineGroup
				.append("line")
					.attr("x1", 10).attr("x2", 10) 
					.attr("y1", 0).attr("y2", height); 
			// Hide hover line by default.
			hoverLine.style("opacity", 0.1);
			
			//hoverLineGroup.call( tipLineChart );
			
			circleBenchMark = svg.append("circle")
				.attr("opacity", 0.00001)
				.attr({	r: dispCircleRadius, fill: 'SpringGreen' });

			circleMF = svg.append("circle")
				.attr("opacity", 0.00001)
				.attr({	r: dispCircleRadius, fill: 'Turquoise' });	
		  
		    d3.select(".chart2").on("mouseover", function() { 
			  
			  console.log('mouseover bugs');
			  
			}).on("mousemove", function() {
			  var xCoOrd = d3.mouse(this)[0];
			  var yCoOrd = d3.mouse(this)[1];
			  //console.log("x and y coordinate Function ENTRY: " + [xCoOrd , yCoOrd] );
			  hoverLine.attr("x1", xCoOrd - margin.left ).attr("x2", xCoOrd - margin.left ).style("opacity", 0.2);
			  
			  
			    var pathLength = benchMarkPath.node().getTotalLength();
				//console.log("bm length " + pathLength );
				//since our hover line has an offset from the xAxis our search
				//needs to begin from there rather than plain xCoord
				var x = xCoOrd - margin.left;
				var beginning = x,
					end = pathLength,
					target;
				while (true) {
					target = Math.floor((beginning + end) / 2);
					posBM = benchMarkPath.node().getPointAtLength(target);
					if ((target === end || target === beginning) && posBM.x !== x) {
						break;
					}
					if (posBM.x > x) end = target;
					else if (posBM.x < x) beginning = target;
					else break; //position found
				}
				//the code below is for the 2nd path i.e. MF line
				//console.log("BEFORE : x and y coordinate where vertical line intersects graph: " + [posBM.x, posBM.y] );
				//decorate the dialogue
				
				locDt = xScaler.invert(posBM.x);
				
				tipLineChart//.attr("transform","translate("+(width - posBM.x)+","+(height - posBM.y)+")")
				.html(function(d) {
					
					return "<strong>dt:</strong> " +locDt.getDate()+"-"+(parseInt(locDt.getMonth())+1)+"-"+locDt.getFullYear() +"<br><strong>"+ dispBMName +" % Chg:</strong> " + retDailyChange( sliced_bm_Data_ , ( xScaler.invert(posBM.x)) ).toFixed(2) + "</span>";
				})		
				
				if(bm_Data_ != current_MF_Data_){
						pathLength = MFPath.node().getTotalLength();
						//console.log("MF length " + pathLength );
						//since our hover line has an offset from the xAxis our search
						//needs to begin from there rather than plain xCoord
						x = xCoOrd - margin.left;
						beginning = x,
							end = pathLength,
							target;
						while (true) {
							target = Math.floor((beginning + end) / 2);
							posMF = MFPath.node().getPointAtLength(target);
							if ((target === end || target === beginning) && posMF.x !== x) {
								break;
							}
							if (posMF.x > x) end = target;
							else if (posMF.x < x) beginning = target;
							else break; //position found
						}
						//console.log("x and y coordinate where vertical line intersects graph: " + [posBM.x, posBM.y,posMF.x, posMF.y] );
						circleMF.attr("opacity", 0.5)
							.attr("cx", posMF.x )
							.attr("cy", posMF.y)
						//console.log("data where vertical line intersects graph: " + [ xScaler.invert(posBM.x), yScaler.invert(posBM.y) ,xScaler.invert(posMF.x), yScaler.invert(posMF.y)]);	
						
						locDt = xScaler.invert(posMF.x);
						//html for hover box
						tipLineChart.html(function(d) {
							
							return "<strong>dt:</strong> " +locDt.getDate()+"-"+(parseInt(locDt.getMonth())+1)+"-"+locDt.getFullYear() +"<br><strong>"+ dispBMName + "% Chg:</strong> " + retDailyChange( sliced_bm_Data_ , ( xScaler.invert(posBM.x)) ).toFixed(2) + "</span><br><strong>"+dispMFName+ "% Change:</strong>" + retDailyChange( current_Data_ , ( xScaler.invert(posMF.x)) ).toFixed(2);
						})
				}
				// end code for 2nd path
				circleBenchMark.attr("opacity", 0.5)
					.attr("cx", posBM.x )
					.attr("cy", posBM.y)
					
				
				
				
				//console.log("data where vertical line intersects graph: " + [xScaler.invert(posBM.x), yScaler.invert(posBM.y)]);

			  
			  tipLineChart.show();
			  //console.log('mousemove x', ( d3.mouse(this)[0] ));
			  //console.log('mousemove y', ( d3.mouse(this)[1] ));
			  
			})  .on("mouseout", function() {
				//console.log('mouseout');
				hoverLine.style("opacity", 0.001);
				circleBenchMark.attr("opacity", 0.001);
				circleMF.attr("opacity", 0.001);
				
				tipLineChart.hide();
		  });
		  		  // Hover line. 
				  
		  
		  xScaler.domain(d3.extent(bm_Data_, function(d) { return d.dt; }));
		  yScaler.domain(d3.extent(bm_Data_, function(d) { return d.closing; }));
		  
		  svg.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate("+marOffsetX+"," + height + ")")
			  .call(xAxis);

		  svg.append("g")
			  .attr("class", "y axis")
			  .call(yAxis)
			  .append("text")
			  .attr("transform", "rotate(-90)")
			  .attr("y", 2)
			  .attr("dy", "1em")
			  .style("text-anchor", "end")
			  .text("Cumulative Change (%)");
		//call the final rendering
		
		_reScaleBM_MF_axes( ".chart23" , "BULL2", 1); 	
		
		
	</script>
	</div>	

	<div id = "MFvsBM1">
	
	<svg class="chart24" id="OK"></svg>
	<script>	
		var margin = {top: 20, right: 30, bottom: 20, left: 30},
		width = MFVsBMWidth - margin.left - margin.right,
		height = MFVsBMHeight - margin.top - margin.bottom;
		//width = 700 , height = 500 ;

		var parsedt = d3.time.format("%d-%b-%y").parse;
		//hopefully store dragslider values
		window.marOffsetX = margin.right;
		window.marOffsetY = margin.top;
		
		var xScaler = d3.time.scale()
			.range([0, width]);

		var yScaler = d3.scale.linear()
			.range([height, 0]);

		var xAxis = d3.svg.axis()
			.scale(xScaler)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScaler)
			.orient("left");

		var tipLineChart = d3.tip()
				  .attr('class', 'd3-tip')
				  //.offset([0, 0])
				  //.html(function(d) {
					//return "<strong>Risk:</strong> " + d.x1 +"<br><strong>Return:</strong> " + d.x2 + "</span>";
				  //})		
			
		var svg = d3.select(".chart24")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + (margin.top) + ")");
			//.attr("transform", "translate(0," + margin.top + ")");
		
		svg.call( tipLineChart );
		//d3.tsv("data.tsv", function(error, data) {
		//**********below is where you should be placing Benchmark data / arrays via static in django ********//
		 
		  //to init we call with 0 ..will need to change it after template mess
		  
		  //add hover line
		  
		  // Hover line. 
			var hoverLineGroup = svg.append("g")
								.attr("class", "hover-line");
			var hoverLine = hoverLineGroup
				.append("line")
					.attr("x1", 10).attr("x2", 10) 
					.attr("y1", 0).attr("y2", height); 
			// Hide hover line by default.
			hoverLine.style("opacity", 0.1);
			
			//hoverLineGroup.call( tipLineChart );
			
			circleBenchMark = svg.append("circle")
				.attr("opacity", 0.00001)
				.attr({	r: dispCircleRadius, fill: 'SpringGreen' });

			circleMF = svg.append("circle")
				.attr("opacity", 0.00001)
				.attr({	r: dispCircleRadius, fill: 'Turquoise' });	
		  
		    d3.select(".chart2").on("mouseover", function() { 
			  
			  console.log('mouseover bugs');
			  
			}).on("mousemove", function() {
			  var xCoOrd = d3.mouse(this)[0];
			  var yCoOrd = d3.mouse(this)[1];
			  //console.log("x and y coordinate Function ENTRY: " + [xCoOrd , yCoOrd] );
			  hoverLine.attr("x1", xCoOrd - margin.left ).attr("x2", xCoOrd - margin.left ).style("opacity", 0.2);
			  
			  
			    var pathLength = benchMarkPath.node().getTotalLength();
				//console.log("bm length " + pathLength );
				//since our hover line has an offset from the xAxis our search
				//needs to begin from there rather than plain xCoord
				var x = xCoOrd - margin.left;
				var beginning = x,
					end = pathLength,
					target;
				while (true) {
					target = Math.floor((beginning + end) / 2);
					posBM = benchMarkPath.node().getPointAtLength(target);
					if ((target === end || target === beginning) && posBM.x !== x) {
						break;
					}
					if (posBM.x > x) end = target;
					else if (posBM.x < x) beginning = target;
					else break; //position found
				}
				//the code below is for the 2nd path i.e. MF line
				//console.log("BEFORE : x and y coordinate where vertical line intersects graph: " + [posBM.x, posBM.y] );
				//decorate the dialogue
				
				locDt = xScaler.invert(posBM.x);
				
				tipLineChart//.attr("transform","translate("+(width - posBM.x)+","+(height - posBM.y)+")")
				.html(function(d) {
					
					return "<strong>dt:</strong> " +locDt.getDate()+"-"+(parseInt(locDt.getMonth())+1)+"-"+locDt.getFullYear() +"<br><strong>"+ dispBMName +" % Chg:</strong> " + retDailyChange( sliced_bm_Data_ , ( xScaler.invert(posBM.x)) ).toFixed(2) + "</span>";
				})		
				
				if(bm_Data_ != current_MF_Data_){
						pathLength = MFPath.node().getTotalLength();
						//console.log("MF length " + pathLength );
						//since our hover line has an offset from the xAxis our search
						//needs to begin from there rather than plain xCoord
						x = xCoOrd - margin.left;
						beginning = x,
							end = pathLength,
							target;
						while (true) {
							target = Math.floor((beginning + end) / 2);
							posMF = MFPath.node().getPointAtLength(target);
							if ((target === end || target === beginning) && posMF.x !== x) {
								break;
							}
							if (posMF.x > x) end = target;
							else if (posMF.x < x) beginning = target;
							else break; //position found
						}
						//console.log("x and y coordinate where vertical line intersects graph: " + [posBM.x, posBM.y,posMF.x, posMF.y] );
						circleMF.attr("opacity", 0.5)
							.attr("cx", posMF.x )
							.attr("cy", posMF.y)
						//console.log("data where vertical line intersects graph: " + [ xScaler.invert(posBM.x), yScaler.invert(posBM.y) ,xScaler.invert(posMF.x), yScaler.invert(posMF.y)]);	
						
						locDt = xScaler.invert(posMF.x);
						//html for hover box
						tipLineChart.html(function(d) {
							
							return "<strong>dt:</strong> " +locDt.getDate()+"-"+(parseInt(locDt.getMonth())+1)+"-"+locDt.getFullYear() +"<br><strong>"+ dispBMName + "% Chg:</strong> " + retDailyChange( sliced_bm_Data_ , ( xScaler.invert(posBM.x)) ).toFixed(2) + "</span><br><strong>"+dispMFName+ "% Change:</strong>" + retDailyChange( current_Data_ , ( xScaler.invert(posMF.x)) ).toFixed(2);
						})
				}
				// end code for 2nd path
				circleBenchMark.attr("opacity", 0.5)
					.attr("cx", posBM.x )
					.attr("cy", posBM.y)
					
				
				
				
				//console.log("data where vertical line intersects graph: " + [xScaler.invert(posBM.x), yScaler.invert(posBM.y)]);

			  
			  tipLineChart.show();
			  //console.log('mousemove x', ( d3.mouse(this)[0] ));
			  //console.log('mousemove y', ( d3.mouse(this)[1] ));
			  
			})  .on("mouseout", function() {
				//console.log('mouseout');
				hoverLine.style("opacity", 0.001);
				circleBenchMark.attr("opacity", 0.001);
				circleMF.attr("opacity", 0.001);
				
				tipLineChart.hide();
		  });
		  		  // Hover line. 
				  
		  
		  xScaler.domain(d3.extent(bm_Data_, function(d) { return d.dt; }));
		  yScaler.domain(d3.extent(bm_Data_, function(d) { return d.closing; }));
		  
		  svg.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate("+marOffsetX+"," + height + ")")
			  .call(xAxis);

		  svg.append("g")
			  .attr("class", "y axis")
			  .call(yAxis)
			  .append("text")
			  .attr("transform", "rotate(-90)")
			  .attr("y", 2)
			  .attr("dy", "1em")
			  .style("text-anchor", "end")
			  .text("Cumulative Change (%)");
		//call the final ren++dering

		
		_reScaleBM_MF_axes(".chart24", "BULL3", 0); 	
		
		
	</script>
	</div>
	
	</div>

	<div id = "lowerHistContainer">
	
	<div id = "MFHist1">
	<svg class="histFlat3"></svg>
        <script>

		genHist(".histFlat3", "BULL2");

	</script>	

	</div>

	<div id = "MFHist1">
	
	<svg class="histFlat4"></svg>
        <script>

		genHist(".histFlat4", "BULL3");
		//now call the message geerator
		genMsg();		
	</script>	
	</div>
	
	</div>

	<script>
	  $(function() {
		window.locList = [];
		for (idx = 0;idx < distSeries.length;idx++){
			locList.push(distSeries[idx]['idx_name']);
		} 
 
		$( "#search" ).autocomplete({
		  delay: 0,
		  source: locList,
		  select: function(event, ui) { 
		  //callback when option is selected
			console.log(ui.item.label)  ;
			$("#loader-wrapper").show();
			$.ajax({
        			type: "POST",
        			url: "http://ec2-52-77-217-54.ap-southeast-1.compute.amazonaws.com:8000/polls/",  // or just url: "/my-url/path/"
        			data: {
            				csrfmiddlewaretoken: '{{ csrf_token }}' ,
            				idx: ui.item.label
        			},
        			success: function(data) {
					$("#loader-wrapper").hide();
            				console.log("Congratulations! You scored: "+ data);
					var parsed = JSON.parse(data);
					refreshWithLatest(parsed);
				
        			},
        			error: function(xhr, textStatus, errorThrown) {
            				alert("Please report this error: "+errorThrown+xhr.status+xhr.responseText);
        			}
    			});
		  }
		});
		
	  });

	$.widget( "custom.catcomplete", $.ui.autocomplete, {
		_create: function() {
		  this._super();
		  this.widget().menu( "option", "items", "> :not(.ui-autocomplete-category)" );
		},
		_renderMenu: function( ul, items ) {
		  var that = this,
			currentCategory = "";
		  $.each( items, function( index, item ) {
			var li;
			if ( item.category != currentCategory ) {
			  ul.append( "<li class='ui-autocomplete-category'>" + item.category + "</li>" );
			  currentCategory = item.category;
			}
			li = that._renderItemData( ul, item );
			if ( item.category ) {
			  li.attr( "aria-label", item.category + " : " + item.label );
			}
		  });
		}
		
	  });
	  
  	</script>

	<script>
			(function() {
	
				function init() {
					var speed = 50,
						easing = mina.easeinout;

					[].slice.call ( document.querySelectorAll( '#grid > a' ) ).forEach( function( el ) {
						var s = Snap( el.querySelector( 'svg' ) ), path = s.select( 'path' ),
							pathConfig = {
								from : path.attr( 'd' ),
								to : el.getAttribute( 'data-path-hover' )
							};

						el.addEventListener( 'mouseenter', function() {
							path.animate( { 'path' : pathConfig.to }, speed, easing );
							$("#info1").fadeIn();
							$("#HDR").fadeIn();
						} );

						el.addEventListener( 'mouseleave', function() {
							path.animate( { 'path' : pathConfig.from }, speed, easing );
							$("#info1").hide();
							$("#HDR").hide();
						} );
					} );
				}

				init();

			})();
	</script>
	
</body>
